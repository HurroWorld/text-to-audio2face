
"""
Full version here: 'C:\Users\houar\AppData\Local\ov\pkg\audio2face-2023.1.1\exts\omni.audio2face.player\omni\audio2face\player\scripts\streaming_server'

This demo script shows how to send audio data to Audio2Face Streaming Audio Player via gRPC requests.
This script uses the PushAudioStreamRequest() method to send audio chunks sequentially.
The script emulates the stream of chunks, generated by splitting an input WAV audio file.
In a real application, such stream of chunks may be acquired from another streaming source:
 * streaming audio via the internet, streaming Text-To-Speech, etc
gRPC protocol details can be found in audio2face.proto
"""

import time
import audio2face_pb2
import audio2face_pb2_grpc
import grpc
import numpy as np
import soundfile
import requests

# Set your desired values here:
PATH_TO_WAV = "C:/Users/houar/Desktop/Audio2Face/output.mp3"
INSTANCE_NAME = "/World/audio2face/PlayerStreaming"

def load_usd_scene_on_server(server_url, usd_scene_path):
    """Load the USD scene on the server and return the loading status message."""
    payload = {"file_name": usd_scene_path}
    try:
        response = requests.post(f'{server_url}/A2F/USD/Load', json=payload)
        response.raise_for_status()
        print(f"USD scene: {response.json()['message']}")
        return response.json()['message']
    except requests.ConnectionError:
        print(f"Error loading USD scene: Unable to connect to Audio2Face server {server_url}.")
        return None

def fetch_a2f_instance_name(server_url):
    """Fetch and return the name of the A2F instance from the server."""
    try:
        response = requests.get(f'{server_url}/A2F/GetInstances').json()
        instance_name = response['result']['fullface_instances'][0]
        print(f'A2F Instance: {instance_name}')
        return instance_name
    except requests.ConnectionError:
        print(f"Error fetching A2F instance: Unable to connect to Audio2Face server {server_url}.")
        return None
    
# Define the server URL
server = 'http://localhost:8011'

# Get A2F instance
a2f_instance_name = fetch_a2f_instance_name(server)

def push_audio_track_stream(url, audio_data, samplerate, instance_name):
    chunk_size = samplerate // 10  # ADJUST
    sleep_between_chunks = 0.04  # ADJUST
    block_until_playback_is_finished = True  # ADJUST

    with grpc.insecure_channel(url) as channel:
        print("Channel creadted")
        stub = audio2face_pb2_grpc.Audio2FaceStub(channel)

        def make_generator():
            start_marker = audio2face_pb2.PushAudioRequestStart(
                samplerate=samplerate,
                instance_name=instance_name,
                block_until_playback_is_finished=block_until_playback_is_finished,
            )
            # At first, we send a message with start_marker
            yield audio2face_pb2.PushAudioStreamRequest(start_marker=start_marker)
            # Then we send messages with audio_data
            for i in range(len(audio_data) // chunk_size + 1):
                time.sleep(sleep_between_chunks)
                chunk = audio_data[i * chunk_size : i * chunk_size + chunk_size]
                yield audio2face_pb2.PushAudioStreamRequest(audio_data=chunk.astype(np.float32).tobytes())

        request_generator = make_generator()
        print("Sending audio data...")
        response = stub.PushAudioStream(request_generator)
        if response.success:
            print("SUCCESS")
        else:
            print(f"ERROR: {response.message}")
    print("Channel closed")

def main():
    """
    This script shows how to send audio data to Audio2Face Streaming Audio Player via gRPC requests using the PushAudioStreamRequest() method.
    """

    # Sleep time emulates long latency of the request
    sleep_time = 2.0  # ADJUST

    # URL of the Audio2Face Streaming Audio Player server (where A2F App is running)
    url = "localhost:50051"  # ADJUST

    data, samplerate = soundfile.read(PATH_TO_WAV, dtype="float32")

    # Only Mono audio is supported
    if len(data.shape) > 1:
        data = np.average(data, axis=1)

    print(f"Sleeping for {sleep_time} seconds")
    time.sleep(sleep_time)

    # Emulate audio stream and push audio chunks sequentially
    push_audio_track_stream(url, data, samplerate, INSTANCE_NAME)

if __name__ == "__main__":
    main()
